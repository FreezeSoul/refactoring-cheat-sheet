---
layout: organizing-data
head_en: Replace Type Code with Subclasses
---
<p>
你有一个不可变的（immutable）type code ，它会影响class 的行为。
<p>
<b>以一个subclass 取代这个type code。</b>
<p class="p-img"><img alt="" src="{{site.baseurl}}/images/08fig10.gif" /></p>

<h3>动机（Motivation）</h3>
<p>
如果你面对的type code 不会影响宿主类的行为，你可以使用Replace Type Code with Class 来处理它们。但如果type code 会影响宿主类的行为，那么最好的办法就是借助多态（polymorphism ）来处理变化行为。
<p>
一般来说，这种情况的标志就是像switch 这样的条件式。这种条件式可能有两种表现形式：switch 语句或者if-then-else 结构。不论哪种形式，它们都是检查type code 值，并根据不同的值执行不同的动作。这种情况下你应该以Replace Conditional with Polymorphism 进行重构。但为了能够顺利进行那样的重构，首先应该将type code 替换为可拥有多态行为的继承体系。这样的一个继承体系应该以type code 的宿主类为base class，并针对每一种type code 各建立一个subclass 。
<p>
为建立这样的继承体系，最简单的办法就是Replace Type Code with Subclasses：以type code 的宿主类为base class，针对每种type code 建立相应的subclass 。 但是以下两种情况你不能那么做：(1) type code 值在对象创建之后发生了改变；(2)  由于某些原因，type code 宿主类已经有了subclass 。如果你恰好面临这两种情况之一，就需要使用Replace Type Code with State/Strategy 。
<p>
Replace Type Code with Subclasses 的主要作用其实是搭建一个舞台，让Replace Conditional with Polymorphism 得以一展身手。如果宿主类中并没有出现条件式，那么 Replace Type Code with Class 更合适，风险也比较低。使用Replace Type Code with Subclasses 的另一个原因就是，宿主类中出现 了「只与具备特定type code 之对象相关」的特性。完成本项重构之后，你可以使用 Push Down Method 和 Push Down Field 将这些特性推到合适的subclass去，以彰显它们「只与特定情况相关」这一事实。
<p>
Replace Type Code with Subclasses 的好处在于：它把「对不同行为的了解」从class 用户那儿转移到了class 自身。如果需要再加入新的行为变化，我只需添加subclass 一个就行了。如果没有多态机制，我就必须找到所有条件式，并逐一修改它们。因此，如果未来还有可能加入新行为，这项重构将特别有价值。

<h3>作法（Mechanics）</h3>
<ul>
  <li>使用Self-encapsulate Field 将type code 自我封装起来。
    <ul>
      <li>如果type code 被传递给构造函数，你就需要将构造函数换成factory method。</li>
    </ul>
  </li>
  <li>为type code 的每一个数值建立一个相应的subclass 。在每个subclass 中覆写（override）type code的取值函数（getter），使其返回相应的type code 值。
    <ul>
      <li>这个值被硬编码于return 中（例如：return 1）。这看起来很骯脏， 但只是权宜之计。当所有case 子句都被替换后，问题就解决了。</li>
    </ul>
  </li>
  <li>每建立一个新的subclass ，编译并测试。</li>
  <li>从superclass 中删掉保存type code 的值域。将type code 访问函数（accessors）声明为抽象函数（abstract method）。</li>
  <li>编译，测试。</li>
</ul>

<h3>范例（Example）</h3>
<p>
为简单起见，我还是使用那个恼人又不切实际的「雇员/薪资」例。我们以Employee 表示「雇员」：
{% highlight java linos %}
 class Employee...
   private int _type;
   static final int ENGINEER = 0;
   static final int SALESMAN = 1;
   static final int MANAGER = 2;

   Employee (int type) {
       _type = type;
   }
{% endhighlight %}

<p>
第一步是以Self-encapsulate Field 将type code 自我封装起来：
{% highlight java linos %}
     int getType() {
       return _type;
   }
{% endhighlight %}
 
<p>
由于Employee 构造函数接受type code 作为一个参数，所以我必须将它替换为一个factory method：
{% highlight java linos %}
   static Employee create(int type) {
       return new Employee(type);
   }
 
   private Employee (int type) {
       _type = type;
   }
{% endhighlight %}
 
<p>
现在，我可以先建立一个subclassEngineer「表示「工程师」。首先我建立这个subclass，并在其中覆写type code 取值函数：
{% highlight java linos %}
 class Engineer extends Employee {
   int getType() {
       return Employee.ENGINEER;
   }
 }
{% endhighlight %}
 
<p>
同时我该修改factory method ，令它返回一个合适的对象：
{% highlight java linos %}
 class Employee
   static Employee create(int type) {
       if (type == ENGINEER) return new Engineer();
       else return new Employee(type);
   }
{% endhighlight %}
 
<p>
然后，我继续逐一地处理其他type code ，直到所有type code 都被替换成subclass 为止。此时我就可以移除Employee 中保存type code 的值域，并将getType() 声明为一个抽象函数。现在，factory method 看起来像这样：
{% highlight java linos %}
   abstract int getType();
 
   static Employee create(int type) {
       switch (type) {
           case ENGINEER:
              return new Engineer();
           case SALESMAN:
              return new Salesman();
           case MANAGER:
              return new Manager();
           default:
              throw new IllegalArgumentException("Incorrect type code value");
       }
   }
{% endhighlight %}

<p>
当然，我总是避免使用switch 语句。但这里只有一处用到switch 语句，并且只用于决定创建何种对象，这样的switch 语句是可以接受的。
<p>
很自然地，在建立了这些subclass 之后，你就应该使用 Push Down Method 和 Push Down Field，将「只与特定种类的雇员相关」的函数和值域推到相关的subclass 去。
