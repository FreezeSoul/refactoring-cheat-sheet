---
layout: organizing-data
head_en: Encapsulate Field
---
<p>
你的class中存在一个public值域。
<p>
将它声明为private，并提供相应的访问函数（accessors）。
{% highlight java linos %}
 public String _name
{% endhighlight %}
<p class="p-img"><img alt="" src="{{site.baseurl}}/images/arrow.gif" /></p>
{% highlight java linos %}
 private String _name;
 public String getName() {return _name;}
 public void setName(String arg) {_name = arg;}
{% endhighlight %}

<h3>动机（Motivation）</h3>
<p>
面向对象的首要原则之一就是封装（encapsulation），或者称为「数据隐藏」（data hidding）。按此原则，你绝不应该将数据声明为public，否则其他对象就有可能访问甚至修改这项数据，而拥有该数据的对象却毫无察觉。这就将数据和行为分开了（不妙）。
<p>
public 数据被看做是一种不好的作法，因为这样会降低程序的模块化程度（modularity）。如果数据和使用该数据的行为被集中在一起，一旦情况发生变化，代码的修改就会比较简单，因为需要修改的代码都集中于同一块地方，而不是星罗棋布地散落在整个程序中。
<p>
Encapsulate Field是封装过程的第一步。通过这项重构手法，你可以将数据隐藏起来，并提供相应的访问函数（accessors）。但它毕竟只是第一步。如果一个class除了访问函数（accessors）外不能提供其他行为，它终究只是一个dumb class (哑类〕。这样的class并不能获得对象技术的优势，而你知道，浪费任何一个对象都是很不好的。实施Encapsulate Field之后，我会尝试寻找那些使用「新建 访问函数」的函数，看看是否可以通过简单的Move Method 轻快地将它们移到新对象去。

<h3>作法（Mechanics）</h3>
<ul>
  <li>为public值域提供取值/设值函数（getter/setter）。</li>
  <li>找到这个class以外使用该值域的所有地点。如果客户只是使用该值域，就把引用动作（reference）替换为「对取值函数（getter）的调用」；如果客户修改了该值域值，就将此一引用点替换为「对设值函数（setter）的调用」。</li>
  <ul>
    <li>如果这个值域是个对象，而客户只不过是调用该对象的某个函数，那么无论该函数是否为修改函数（modifier，会改变对象状态），都只 能算是使用该值域。只有当客户为该值域赋值时，才能将其替换为设值函数（setter）。</li>
  </ul>
  <li>每次修改之后，编译并测试。</li>
  <li>将值域的所有用户修改完毕后，把值域声明private。</li>
  <li>编译，测试。</li>
</ul>
