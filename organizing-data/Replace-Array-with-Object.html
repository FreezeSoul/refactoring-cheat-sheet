---
layout: organizing-data
head_en: Replace Array with Object
---
<p>
你有一个数组（array），其中的元素各自代表不同的东西。
<p>
以对象替换数组。对于数组中的每个元素，以一个值域表示之。
{% highlight java linos %}
  String[] row = new String[3];
  row [0] = "Liverpool";
  row [1] = "15";
{% endhighlight %}

<p>===></p>
{% highlight java linos %}
  Performance row = new Performance();
  row.setName("Liverpool");
  row.setWins("15");
{% endhighlight %}

<h3>动机（Motivation）</h3>
<p>
数组（array）是一种常见的用以组织数据的结构体。不过，它们应该只用于「以某种顺序容纳一组相似对象」。有时候你会发现，一个数组容纳了数种不同对象，这会给array用户带来麻烦，因为他们很难记住像「数组的第一个元素是人名」这样的约定。对象就不同了，你可以运用值域名称和函数名称来传达这样的信息，因此你无需死记它，也无需倚赖注释。而且如果使用对象，你还可以将信息封装起来，并使用<a href="{{site.baseurl}}/moving-features-between-objects/Move-Method.html">Move Method</a> 为它加上相关行为。

<h3>作法（Mechanics）</h3>
<ul>
  <li>新建一个class表示数组所示信息，并在该class中以一个public值域保存原先的数组。</li>
  <li>修改数组的所有用户，让它们改用新建的class实体。</li>
  <li>编译，测试。</li>
  <li>逐一为数组元素添加取值/设值函数（getters/setters）。根据元素的用途，为这些访问函数命名。修改客户端代码，让它们通过访问函数取用数组内的元素。 每次修改后，编译并测试。</li>
  <li>当所有「对数组的直接访问」都被取代为「对访问函数的调用」后，将class之中保存该数组的值域声明private。</li>
  <li>编译。</li>
  <li>对于数组内的每一个元素，在新class中创建一个型别相当的值域；修改该元素的访问函数，令它改用上述的新建值域。</li>
  <li>每修改一个元素，编译并测试。</li>
  <li>数组的所有元素都在对应的class内有了相应值域之后，删除该数组。</li>
</ul>

<h3>范例（Example）</h3>
<p>
我们的范例从一个数组开始，其中有三个元素，分别保存一支球队的名称、获胜场 次和失利场次。这个数组的声明可能像这样：
{% highlight java linos %}
  String[] row = new String[3];
{% endhighlight %}
<p>
客户端代码可能像这样：
{% highlight java linos %}
   row [0] = "Liverpool";
   row [1] = "15";

   String name = row[0];
   int wins = Integer.parseInt(row[1]);
{% endhighlight %}

<p>
为了将数组变成对象，我首先建立一个对应的class：
{% highlight java linos %}
  class Performance {}
{% endhighlight %}

<p>
然后为它声明一个public值域，用以保存原先数组。〔我知道public值域十恶不赦，请放心，稍后我便让它改邪归正。）
{% highlight java linos %}
  public String[] _data = new String[3];
{% endhighlight %}

<p>
现在，我要找到创建和访问数组的地方。在创建地点，我将它替换为下列代码：
{% highlight java linos %}
  Performance row = new Performance();
{% endhighlight %}

<p>
对于数组使用地点，我将它替换为以下代码：
{% highlight java linos %}
   row._data [0] = "Liverpool";
   row._data  [1] = "15";

   String name = row._data[0];
   int wins = Integer.parseInt(row._data[1]);
{% endhighlight %}

<p>
然后我要逐一为数组元素加上有意义的取值/设值函数（getter/setter）。首先从「球队名称」开始：
{% highlight java linos %}
 class Performance...
   public String getName() {
       return _data[0];
   }
   public void setName(String arg) {
       _data[0] = arg;
   }
{% endhighlight %}

<p>
然后修改row对象的用户，让他们改用「取值丨设值函数」来访问球队名称：
{% highlight java linos %}
   row.setName("Liverpool");
   row._data  [1] = "15";

   String name = row.getName();
   int wins = Integer.parseInt(row._data[1]);
{% endhighlight %}

<p>
第二个元素也如法炮制。为了简单起见，我还可以把数据型别的转换也封装起来：
{% highlight java linos %}
 class Performance...
   public int getWins() {
       return Integer.parseInt(_data[1]);
   }
   public void setWins(String arg) {
       _data[1] = arg;
   }

 ....
 client code...
   row.setName("Liverpool");
   row.setWins("15");

   String name = row.getName();
   int wins = row.getWins();
{% endhighlight %}

<P>
处理完所有元素之后，我就可以将保存该数组的值域声明为private了。
{% highlight java linos %}
   private String[] _data = new String[3];
{% endhighlight %}

<P>
现在，本次重构最重要的部分（接口修改）已经完成。但是「将对象内的数组替换掉」的过程也同样重要。我可以针对每个数组元素，在内建立一个型别相当的值域，然后修改该数组元素的访问函数，令它直接访问新建值域，从而完全摆脱 对数组元素的依赖。
{% highlight java linos %}
 class Performance...
   public String getName() {
       return _name;
   }
   public void setName(String arg) {
      _name = arg;
   }
   private String _name;
{% endhighlight %}

<p>
对数组中的每一个元素都如法炮制。全部处理完毕后，我就可以将数组从我的Performance class删掉了。
