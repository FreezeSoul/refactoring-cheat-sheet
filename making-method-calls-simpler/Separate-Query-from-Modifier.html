---
layout: making-method-calls-simpler
head_en: Separate Query from Modifier
---
<p>
某个函数既返回对象状态值，又修改对象状态（state）。
<p><b>建立两个不同的函数，其中一个负责査询，另一个负责修改。</b></p>

<p class="p-img"><img alt="" src="{{site.baseurl}}/images/10fig04.gif" /></p>

<h3>动机（Motivation）</h3>
<p>
如果某个函数只是向你提供一个值，没有任何看得到的副作用（或说连带影响）， 那么这是个很有价值的东西。你可以任意调用这个函数，也可以把调用动作搬到函 数的其他地方。简而言之，需要操心的事情少多了。
<p>
明确表现出「有副作用」与「无副作用」两种函数之间的差异，是个很好的想法。 下而是一条好规则：任何有返回值的函数，都不应该有看得到的副作用。有些程序 员甚至将此作为一条必须遵守的规则[Meyer]。就像对待任何东西一样，我并不绝对遵守它，不过我总是尽量遵守，而它也回报我很好的效果。
<p>
如果你遇到一个「既有返回值又有副作用」的函数，就应该试着将查询动作从修改 动作中分割出来。
<p>
你也许已经注意到了 ：我使用「看得到的副作用」这种说法。有一种常见的优化办法是：将查询所得结果高速缓存（cache）于某个值域中，这么一来后续的重复查询 就可以大大加快速度。虽然这种作法改变了对象的状态，但这一修改是察觉不到的，因为不论如何査询，你总是获得相同结果[Meyer]。

<h3>作法（Mechanics）</h3>
<ul>
  <li>新建一个查询函数，令它返回的值与原函数相同。
    <ul>
      <li>观察原函数，看它返回什么东西。如果返回的是一个临时变量，找出临时变量的位置。</li>
    </ul>
  </li>
  <li>修改原函数，令它调用查询函数，并返回获得的结果。
    <ul>
    <li>原函数中的每个return 句都应该像这样：return newQuery()，而不应该返回其他东西。</li>
    <li>如果调用者将返回值赋给了一个临时变量，你应该能够去除这个临时 变量。</li>
    </ul>
  </li>
  <li>编译，测试。</li>
  <li>将「原函数的每一个被调用点」替换为「对查询函数的调用」。然后，在调用査询函数的那一行之前，加上对原函数的调用。每次修改后，编译并测试。</li>
  <li>将原函数的返回值改为void。丨山并删掉其中所有的return 句。</li>
</ul>

<h3>范例：（Example）</h3>
<p>
有这样一个函数：一旦有人入侵安全系统，它会告诉我入侵者的名字，并发送一个警报。如果入侵者不止一个，也只发送一条警报：
{% highlight java linos %}
  String foundMiscreant(String[] people){
      for (int i = 0; i < people.length; i++) {
          if (people[i].equals ("Don")){
             sendAlert();
             return "Don";
          }
          if (people[i].equals ("John")){
             sendAlert();
             return "John";
          }
      }
      return "";
  }
{% endhighlight %}

该函数被下列代码调用：
{% highlight java linos %}
  void checkSecurity(String[] people) {
      String found = foundMiscreant(people);
      someLaterCode(found);
  }
{% endhighlight %}

为了将查询动作和修改动作分开，我首先建立一个适当的查询函数，使其与修改函 数返回相同的值，但不造成任何副作用：
{% highlight java linos %}
   String foundPerson(String[] people){
       for (int i = 0; i < people.length; i++) {
           if (people[i].equals ("Don")){
              return "Don";
           }
           if (people[i].equals ("John")){
              return "John";
           }
       }
       return "";
   }
{% endhighlight %}

然后，我要逐一替换原函数内所有的?如皿句，改调用新建的查询函数。每次替换后，编译并测试。这一步完成之后，原函数如下所示：
{% highlight java linos %}
  String foundMiscreant(String[] people){
      for (int i = 0; i < people.length; i++) {
          if (people[i].equals ("Don")){
             sendAlert();
             return foundPerson(people);
          }
          if (people[i].equals ("John")){
             sendAlert();
             return foundPerson(people);
          }
      }
      return foundPerson(people);
  }
{% endhighlight %}

现在，我要修改调用者，将原本的单一调用动作替换为两个调用：先调用修改函数，然后调用查询函数：
{% highlight java linos %}
  void checkSecurity(String[] people) {
      foundMiscreant(people);
      String found = foundPerson(people);
      someLaterCode(found);
  }
{% endhighlight %}

所有调用都替换完毕后，我就可以将修改函数的返回值改为void：
{% highlight java linos %}
  void foundMiscreant (String[] people){
      for (int i = 0; i < people.length; i++) {
          if (people[i].equals ("Don")){
             sendAlert();
             return;

          }
          if (people[i].equals ("John")){
             sendAlert();
             return;
          }
      }
  }
{% endhighlight %}

现在，为原函数改个名称可能会更好一些：
{% highlight java linos %}
  void sendAlert (String[] people){
      for (int i = 0; i < people.length; i++) {
          if (people[i].equals ("Don")){
             sendAlert();
             return;

          }
          if (people[i].equals ("John")){
             sendAlert();
             return;
          }
      }
  }
{% endhighlight %}

<p>
当然，这种情况下，我得到了大量重复代码，因为修改函数之中使用了与查询函数相同的代码。现在我可以对修改函数实施<a href="{{site.baseurl}}/composing-methods/Substitute-Algorithm.html">Substitute Algorithm</a> ，设法让它再简洁一些：
{% highlight java linos %}
  void sendAlert(String[] people){
      if (! foundPerson(people).equals(""))
          sendAlert();
  }
{% endhighlight %}

<h3>并发（Concurrency）问题</h3>
<p>
如果你在一个多线程系统中工作，肯定知道这样一个重要的惯用手法：在同一个动作中完成检查和赋值。这是否和<a href="{{site.baseurl}}/making-method-calls-simpler/Separate-Query-from-Modifier.html">Separate Query from Modifier</a> 互相矛盾呢？ 我曾经和Doug Lea 讨论过这个问题，并得出结论：两者并不矛盾，但你需要做一 些额外工作。将查询动作和修改动作分开来仍然是很有价值的。但你需要保留第三个函数来同时做这两件事。这个「查询-修改」函数将调用各自独立的查询函数和 修改函数，并被声明为synchronized 时。如果查询函数和修改函数未被声明为synchronized ，那么你还应该将它们的可见范围限制在package 级别或private 级别。这样，你就可以拥有一个安全、同步的操作，它由两个较易理解的函数组成。 这两个较低层函数也可以用于其他场合。
