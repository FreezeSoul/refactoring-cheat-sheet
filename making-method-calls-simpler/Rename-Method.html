---
layout: making-method-calls-simpler
head_en: Rename Method
---
<p>
函数的名称未能揭示函数的用途。
<p><b>修改函数名称。</b></p>

<p class="p-img"><img alt="" src="{{site.baseurl}}/images/10fig01.gif" /></p>

<h3>动机（Motivation）</h3>
<p>
我极力提倡的一种编程风格就是：将复杂的处理过程分解成小函数。但是，如果做得不好，这会使你费尽周折却弄不清楚这些小函数各自的用途。要避免这种麻烦，关键就在于给函数起一个好名称。函数的名称应该准确表达它的用途。给函数命名有一个好办法：首先考虑应该给这个函数写上一句怎样的注释，然后想办法将注释变成函数名称。
<p>
人生不如意，十之八九。你常常无法第一次就给函数起一个好名称。这时候你可能会想：就这样将就着吧——毕竟只是一个名称而已。当心！这是恶魔的召唤，是通 向混乱之路，千万不要被它诱惑！如果你看到一个函数名称不能很好地表达它的用 途，应该马上加以修改。记住，你的代码首先是为人写的，其次才是为计算器写的。 而人需要良好名称的函数。想想过去曾经浪费的无数时间吧。如果给每个函数都起一个良好的名称，也许你可以节约好多时间。起一个好名称并不容易，需要经验； 要想成为一个真正的编程高手，「起名称」的水平是至关重要的。当然，函数签名式（signature）中的其他部分也一样重要；如果重新安排参数顺序，能够帮助提高代码的清晰度，那就大胆地去做吧，你有 <a href="{{site.baseurl}}/making-method-calls-simpler/Add-Parameter.html">Add Parameter</a> 和<a href="{{site.baseurl}}/making-method-calls-simpler/Remove-Parameter.html">Remove Parameter</a> 这两项武器。

<h3>作法（Mechanics）</h3>
<ul>
  <li>检查函数签名式（signature）是否被superclass 或subclass 实现过。如果是，则需要针对每份实现品分别进行下列步骤。</li>
  <li>声明一个新函数，将它命名为你想要的新名称。将旧函数的代码拷贝到新函数中，并进行适当调整。</li>
  <li>编译。</li>
  <li>修改旧函数，令它将调用转发给新函数。
    <ul>
      <li>如果只有少数几个地方引用旧函数，你可以大胆地跳过这一步骤。</li>
    </ul>
  </li>
  <li>编译，测试。</li>
  <li>找出旧函数的所有被引用点，修改它们，令它们改而引用新函数。每次修改后，编译并测试。</li>
  <li>删除旧函数。
    <ul>
      <li>如果旧函数是class public 接口的一部分，你可能无法安全地删除它。这种情况下，将它保留在原处，并将它标记为"deprecated"（不再被赞同）。</li>
    </ul>
  </li>
  <li>编译，测试。
</ul>

<h3>范例（Example）</h3>
<p>
我以getTelephoneNumber() 函数来取得某人的电话号码：
{% highlight java linos %}
  public String getTelephoneNumber() {
      return ("(" + _officeAreaCode + ") " + _officeNumber);
  }
{% endhighlight %}

<p>
现在，我想把这个函数改名为getOfficeTelephoneNumber() 。首先建立一个新函 数，命名为getOfficeTelephoneNumber() ，并将原函数getTelephoneNumber() 的代码拷贝过来。然后，让旧函数直接调用新函数：
{% highlight java linos %}
 class Person...
   public String getTelephoneNumber(){
       return getOfficeTelephoneNumber();
   }
   public String getOfficeTelephoneNumber() {
       return ("(" + _officeAreaCode + ") " + _officeNumber);
   }
{% endhighlight %}

<p>
现在，我需要找到旧函数的所有调用者，将它们全部改为调用新函数。全部修改完 后，就可以将旧函数删掉了。
<p>
如果需要添加或去除某个参数，过程也大致相同。
<p>
如果旧函数的调用者并不多，我可以直接修改这些调用者，令它们调用新函数，不必让旧函数充当中介。如果测试出错，我可以回到起始处，并放慢前进速度。
