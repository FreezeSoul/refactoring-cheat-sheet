---
layout: making-method-calls-simpler
head_en: Replace Parameter with Method
---
<p>
对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数也可以（也有能力）调用前一个函数。
<p><b>让参数接受者去除该项参数，并直接调用前一个函数。</b></p>
{% highlight java linos %}
     int basePrice = _quantity * _itemPrice;
     discountLevel = getDiscountLevel();
     double finalPrice = discountedPrice (basePrice, discountLevel);
{% endhighlight %}
<p class="p-img"><img  alt="" src="{{site.baseurl}}/images/arrow.gif" /></p>
{% highlight java linos %}
     int basePrice = _quantity * _itemPrice;
     double finalPrice = discountedPrice (basePrice);
{% endhighlight %}


<h3>动机（Motivation）</h3>
<p>
如果函数可以通过其他途径（而非参数列〕获得参数值，那么它就不应该通过参数取得该值。过长的参数列会增加程序阅读者的理解难度，因此我们应该尽可能缩短参数列的长度。
<p>
缩减参数列的办法之一就是，看看「参数接受端（receiver）」是否可以通过「与调用端相同的计算」来取得参数携带值。如果调用端通过「其所属对象内部的另一个函数」来计算参数，并在计算过程中「未曾引用调用端的其他参数」（译注：亦就是说没有太多与外界的相依关系），那么你就应该可以将这个计算过程转移到被调用端内，从而去除该项参数。如果你所调用的函数隶属另一对象，而该对象拥有一个reference 指向调用端所属对象，前面所说的这些也同样适用。
<p>
但是，如果「参数计算过程」倚赖调用端的某个参数，那么你就无法去掉被调用端的那个参数，因为每一次调用动作中，该参数值都可能不同（当然，如果你能够运用<a href="{{site.baseurl}}/making-method-calls-simpler/Replace-Parameter-with-Explicit-Methods.html">Replace Parameter with Explicit Methods</a> 将该参数替换为一个函数，又另当别论）。另外，如果参数接受端（receiver）并没有一个reference 指向参数发送端（sender），而你也不想加上这样一个reference ，那么也无法去除参数。
<p>
有时候，参数的存在是为了将来的弹性。这种情况下我仍然会把这种多余参数拿掉。是的，你应该只在必要关头才添加参数，预先添加的参数很可能并不是你所需要的。不过，对于这条规则，也有一个例外：如果修改接口会对整个程序造成非常痛苦的结果（例如需要很长时间来重建程序，或需要修改大量代码〕，那么可以考虑保留前人预先加入的参数。如果真是这样，你应该首先判断修改接口究竟会造成多严重的后果，然后考虑是否「降低系统各部位之间的依存程度」以减少「修改接口所造成的影响」。稳定的接口确实很好，但是被冻结在一个不良接 口上，也是有问题的。

<h3>作法（Mechanics）</h3>
<ul>
  <li>如果有必要，将参数的计算过程提炼到一个独立函数中。</li>
  <li>将函数本体内「对该参数的引用」替换为「对新建函数的调用」。</li>
  <li>每次替换后，修改并测试。</li>
  <li>全部替换完成后，使用<a href="{{site.baseurl}}/making-method-calls-simpler/Remove-Parameter.html">Remove Parameter</a> 将该参数去掉。</li>
</ul>

<h3>范例：（Example）</h3>
<p>
以下代码用于计算定单折扣价格。虽然这么低的折扣不大可能出现在现实生活中， 不过作为一个范例，我们暂不考虑这一点：
{% highlight java linos %}
  public double getPrice() {
      int basePrice = _quantity * _itemPrice;
      int discountLevel;
      if (_quantity > 100) discountLevel = 2;
      else discountLevel = 1;
      double finalPrice = discountedPrice (basePrice, discountLevel);
      return finalPrice;
  }

  private double discountedPrice (int basePrice, int discountLevel) {
      if (discountLevel == 2) return basePrice * 0.1;
      else return basePrice * 0.05;
  }
{% endhighlight %}

<p>
首先，我把计算折扣等级（discountLevel）的代码提炼成为一个独立的 getDiscountLevel() 函数：
{% highlight java linos %}
  public double getPrice() {
      int basePrice = _quantity * _itemPrice;
      int discountLevel = getDiscountLevel();
      double finalPrice = discountedPrice (basePrice, discountLevel);
      return finalPrice;
  }

  private int getDiscountLevel() {
      if (_quantity > 100) return 2;
      else return 1;
  }
{% endhighlight %}

然后把discountedPrice() 函数中对discountLevel 参数的所有引用点，替换为getDiscountLevel() 函数的调用：
{% highlight java linos %}
  private double discountedPrice (int basePrice, int discountLevel) {
      if (getDiscountLevel() == 2) return basePrice * 0.1;
      else return basePrice * 0.05;
  }
{% endhighlight %}

此时我就可以使用<a href="{{site.baseurl}}/making-method-calls-simpler/Remove-Parameter.html">Remove Parameter</a> 去掉discountLevel 参数了 ：
{% highlight java linos %}
  public double getPrice() {
      int basePrice = _quantity * _itemPrice;
      int discountLevel = getDiscountLevel();
      double finalPrice = discountedPrice (basePrice);
      return finalPrice;
  }

  private double discountedPrice (int basePrice) {
      if (getDiscountLevel() == 2) return basePrice * 0.1;
      else return basePrice * 0.05;
  }
{% endhighlight %}

接下来可以将discountLevel 变量去除掉：
{% highlight java linos %}
  public double getPrice() {
      int basePrice = _quantity * _itemPrice;
      double finalPrice = discountedPrice (basePrice);
      return finalPrice;
  }
{% endhighlight %}

现在，可以去掉其他非必要的参数和相应的临时变量。最后获得以下代码：
{% highlight java linos %}
  public double getPrice() {
      return discountedPrice ();
  }

  private double discountedPrice () {
      if (getDiscountLevel() == 2) return getBasePrice() * 0.1;
      else return getBasePrice() * 0.05;
  }

  private double getBasePrice() {
      return _quantity * _itemPrice;
  }
{% endhighlight %}

最后我还可以针对discountedPrice() 函数使用Inline Method：
{% highlight java linos %}
  private double getPrice () {
      if (getDiscountLevel() == 2) return getBasePrice() * 0.1;
      else return getBasePrice() * 0.05;
  }
{% endhighlight %}
