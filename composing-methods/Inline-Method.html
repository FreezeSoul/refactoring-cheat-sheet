---
layout: composing-methods
head_en: Inline Method
---

<p>
一个函数，其本体（method body）应该与其名称（method name)同样清楚易懂。
<p>
在函数调用点插入函数本体，然后移除该函数。
{% highlight java linos %}
int getRating() {
  return (moreThanFiveLateDeliveries()) ? 2 : 1;
}
boolean moreThanFiveLateDeliveries() {
  return _numberOfLateDeliveries > 5;
}
{% endhighlight %}

<p> ===> </p>
{% highlight java linos %}
int getRating() {
  return (_numberOfLateDeliveries > 5) ? 2 : 1;
}
{% endhighlight %}

<h3>动机（Motivation）</h3>
<p>
本书经常以简短的函数表现动作意图，这样会使代码更清晰易读。但有时候你会遇到某些函数，其内部代码和函数名称同样清晰易读。也可能你重构了该函数，使得其内容和其名称变得同样清晰。果真如此，你就应该去掉这个函数，直接使用其中的代码。间接性可能带来帮助，但非必要的间接性总是让人不舒服。
<p>
另一种需要使用Inline Method 的情况是：你手上有一群组织不甚合理的函数。你可以将它们都inline到一个大型函数中，再从中提炼出组织合理的小型函数。Kent Beck发现，实施 Replace Method with Method Object 之前先这么做，往往可以获得不错的效果。你可以把你所要的函数（有着你要的行为）的所有调用对象的函数内容都inline到method object（函数对象）中。比起既要移动一个函数，又要移动它所调用的其他所有函数，「将大型函数作为单一整体来移动」会比较简单。
<p>
如果别人使用了太多间接层，使得系统中的所有函数都似乎只是对另一个函数的简单委托（delegation），造成我在这些委托动作之间晕头转向，那么我通常都会使用Inline Method。当然，间接层有其价值，但不是所有间接层都有价值。试着使用inlining，我可以找出那些有用的间接层，同时将那些无用的间接层去除。

<h3>作法（Mechanics）</h3>
 
*	检查函数，确定它不具多态性（is not polymorphic）。
	** 如果subclass继承了这个函数,就不要将此函数inline化，因为subclass无法覆写（overridde）一个根本不存在的函数。
*	找出这个函数的所有被调用点。
*	将这个函数的所有被调用点都替换为函数本体（代码）。
*	编译，测试。
*	删除该函数的定义。

<p>
被我这样一写，Inline Method 似乎很简单。但情况往往并非如此。对于递归调用、多返回点、inlining至另一个对象中而该对象并无提供访问函数（accessors）……，每一种情况我都可以写上好几页。我之所以不写这些特殊情况， 原因很简单：如果你遇到了这样的复杂情况，那么就不应该使用这个重构手法。

