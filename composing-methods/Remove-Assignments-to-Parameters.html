---
layout: composing-methods
head_en: Remove Assignments to Parameters
---
<p>
你的代码对一个参数进行赋值动作。
<p> 
<b>以一个临时变量取代该参数的位置。</b>
{% highlight java linos %}
   int discount (int inputVal, int quantity, int yearToDate) {
       if (inputVal > 50) inputVal -= 2;
{% endhighlight %}	   
	  <p><img alt="" src="/refactoring-cheat-sheet/images/arrow.gif"/></p>
{% highlight java linos %}	   
   int discount (int inputVal, int quantity, int yearToDate) {
       int result = inputVal;
       if (inputVal > 50) result -= 2;
{% endhighlight %} 

<br>
<h3>动机（Motivation）</h3>
<p> 
首先，我要确定大家都清楚「对参数赋值」这个说法的意思。如果你把一个名为foo 的对象作为参数传给某个函数，那么「对参数赋值」意味改变foo，使它引用（参考、指涉、指向）另一个对象。如果你在「被传入对象」身上进行什么操作，那没问题，我也总是这样干。我只针对「foo被改而指向（引用）完全不同的另一个对象」这种情况来讨论：

{% highlight java linos %} 
 void aMethod(Object foo) {
   foo.modifyInSomeWay();           // that's OK
   foo = anotherObject;             // trouble and despair will follow you
{% endhighlight %} 
<p> 
我之所以不喜欢这样的作法，因为它降低了代码的清晰度，而且混淆了 pass by value（传值〕和 pass by reference (传址）这两种参数传递方式。Java只采用 pass by value传递方式（稍后讨论），我们的讨论也正是基于这一点。
<p> 
在 pass by value情况下，对参数的任何修改，都不会对调用端造成任何影响。那些用过 pass by reference的人可能会在这一点上犯糊涂。
<p> 
另一个让人糊涂的地方是函数本体内。如果你只以参数表示「被传递进来的东西」，那么代码会清晰得多，因为这种用法在所有语言中都表现出相同语义。
<p> 
在Java中，不要对参数赋值；如果你看到手上的代码已经这样做了，请使用<a href="{{site.baseurl}}/composing-methods/Remove-Assignments-to-Parameters.html">Remove Assignments to Parameters</a>。
<p>
当然，面对那些使用「输出式参数」（ output parameters）的语言，你不必遵循这条规则。不过在那些语言中我会尽量少用输出式参数。</p>
 
<br>
<h3>作法（Mechanics）</h3>
<ul> 
	<li>建立一个临时变量，把待处理的参数值赋予它。</li>
 
	<li>以「对参数的赋值动作」为界，将其后所有对此参数的引用点，全部替换为「对此临时变量的引用动作」。</li>
 
	<li>修改赋值语句，使其改为对新建之临时变量赋值。</li>
 
	<li>编译，测试。</li>

	<ul><li>如果代码的语义是 pass by reference，请在调用端检查调用后是否还使用了这个参数。也要检查有多少个 pass by reference参数「被赋值后又被使用」。请尽量只以return方式返回一个值。如果需要返回的值不只一个，看看可否把需返回的大堆数据变成单一对象，或千脆为每个返回值设计对应的一个独立函数。</li></ul>
</ul> 

<br>
<h3>范例（Example）</h3>
<p> 
我从下列这段简单代码开始：
{% highlight java linos %}  
   int discount (int inputVal, int quantity, int yearToDate) {
       if (inputVal > 50) inputVal -= 2;
       if (quantity > 100) inputVal -= 1;
       if (yearToDate > 10000) inputVal -= 4;
       return inputVal;
   }
{% endhighlight %}
<p> 
以临时变量取代对参数的赋值动作，得到下列代码：
{% highlight java linos %}  
   int discount (int inputVal, int quantity, int yearToDate) {
     int result = inputVal;
       if (inputVal > 50) result -= 2;
       if (quantity > 100) result -= 1;
       if (yearToDate > 10000) result -= 4;
       return result;
   }
{% endhighlight %}
<p>
还可以为参数加上关键词final，从而强制它遵循「不对参数赋值」这一惯例：
{% highlight java linos %}   
   int discount (final int inputVal, final int quantity, final int yearToDate) {
       int result = inputVal;
       if (inputVal > 50) result -= 2;
       if (quantity > 100) result -= 1;
       if (yearToDate > 10000) result -= 4;
       return result;
   }
{% endhighlight %}
<p>
不过我得承认，我并不经常使用final来修饰参数，因为我发现，对于提高短函数的清晰度，这个办法并无太大帮助。我通常会在较长的函数中使用它，让它帮助我检查参数是否被做了修改。
</p>
 
<br>
<h3>Java 的 pass by value（传值）</h3>
<p> 
Java使用"pass by value"「函数调用」方式，这常常造成许多人迷惑。在所有地点，Java都严格釆用pass by value，所以下列程序：
{% highlight java linos %}    
 class Param {
   public static void main(String[] args) {
       int x = 5;
       triple(x);
       System.out.println ("x after triple: " + x);
   }
   private static void triple(int arg) {
       arg = arg * 3;
       System.out.println ("arg in triple: " + arg);
   }
}
{% endhighlight %}

<p> 
会产生这样的输出：

{% highlight java linos %}  
 arg in triple: 15
 x after triple: 5
{% endhighlight %} 

<p>
这段代码还不至于让人糊涂。但如果参数中传递的是对象，就可能把人弄迷糊了。如果我在程序中以Date对象表示日期，那么下列程序：

{% highlight java linos %}  
 class Param {
 
   public static void main(String[] args) {
       Date d1 = new Date ("1 Apr 98");
       nextDateUpdate(d1);
       System.out.println ("d1 after nextDay: " + d1);
 
       Date d2 = new Date ("1 Apr 98");
       nextDateReplace(d2);
       System.out.println ("d2 after nextDay: " + d2);
   }
 
   private static void nextDateUpdate (Date arg) {
       arg.setDate(arg.getDate() + 1);
       System.out.println ("arg in nextDay: " + arg);
   }
 
   private static void nextDateReplace (Date arg) {
       arg = new Date (arg.getYear(), arg.getMonth(), arg.getDate() + 1);
       System.out.println ("arg in nextDay: " + arg);
   }
 }
{% endhighlight %} 

<p>
产生的输出是：

{% highlight java linos %}  
 arg in nextDay: Thu Apr 02 00:00:00 EST 1998
 d1 after nextDay: Thu Apr 02 00:00:00 EST 1998
 arg in nextDay: Thu Apr 02 00:00:00 EST 1998
 d2 after nextDay: Wed Apr 01 00:00:00 EST 1998
{% endhighlight %}

<p> 
从本质上说，object reference是按值传递的（passed by value）。因此我可以修改参数对象的内部状态，但对参数对象重新赋值，没有意义。
<p>
Java1.1及其后版本，允许你将参数标示为final，从而避免函数中对参数赋值。 即使某个参数被标示为final，你仍然可以修改它所指向的对象。我总是把参数视为final，但是我得承认，我很少在参数列（parameter list）中这样标示它们。