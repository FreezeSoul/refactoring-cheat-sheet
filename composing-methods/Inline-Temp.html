---
layout: composing-methods
head_en: Inline Temp
---
<p>
你有一个临时变量，只被一个简单表达式赋值一次，而它妨碍了其他重构手法。
<p> 
<b>将所有对该变量的引用动作，替换为对它赋值的那个表达式本身。</b>

{% highlight java linos %} 
    double basePrice = anOrder.basePrice();
    return (basePrice > 1000)
	{% endhighlight %}
<p><img alt="" src="/refactoring-cheat-sheet/images/arrow.gif"/></p>
{% highlight java linos %} 
return (anOrder.basePrice() > 1000)
{% endhighlight %}

<br>
<h3>动机（Motivation）</h3>

<p>
<a href="{{site.baseurl}}/composing-methods/Inline-Temp.html">Inline Temp</a>多半是作为<a href="{{site.baseurl}}/composing-methods/Replace-Temp-with-Query.html">Replace Temp with Query</a> 的一部分来使用，所以真正的动机出现在后者那儿。惟一单独使用<a href="{{site.baseurl}}/composing-methods/Inline-Temp.html">Inline Temp</a>的情况是：你发现某个临时变量被赋予某个函数调用的返回值。一般来说，这样的临时变量不会有任何危害，你可以放心地把它留在那儿。但如果这个临时变量妨碍了其他的重构 手法——例如<a href="{{site.baseurl}}/composing-methods/Extract-Method.html">Extract Method</a>，你就应该将它inline化。</p>

<br>
<h3>作法（Mechanics）</h3>
<ul>
  <li>如果这个临时变量并未被声明为final，那就将它声明为final，然后编译。</li>
  <ul><li>这可以检查该临时变量是否真的只被赋值一次。</li></ul>
  <li>找到该临时变量的所有引用点，将它们替换为「为临时变量赋值」之语句中的等号右侧表达式。</li>
  <li>每次修改后，编译并测试。</li>
  <li>修改完所有引用点之后，删除该临时变量的声明式和赋值语句。</li>
  <li>编译，测试。</li>
<ul>
